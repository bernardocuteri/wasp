#!/usr/bin/python3
import sys
import random
from random import randint

withConstants = True

arieties = []
usedVariables = []
arithmeticRelations = [">", "<", "<=", ">=", "!=", "="]
arithmeticOperators = ["+", "-"]#, "*", "/"]

def getRandomElement(array):
    return array[randint(0, len(array)-1)]

def getUsedVariable():
    return getRandomElement(usedVariables)

def getRandomAggregateAtom():
    toReturn = ""
    predicateId = randint(0, numberOfPredicates-1)
    ariety = arieties[predicateId]
    while ariety==0:
        predicateId = randint(0, numberOfPredicates-1)
        ariety = arieties[predicateId]
    
    toReturn += "p_" + str(predicateId) 
    
    if ariety > 0:
        toReturn += "("
    for i in range(arieties[predicateId]):
        if i > 0:
            toReturn += ","
        variable = "X_" + str(randint(0, numberOfVariables-1))
        toReturn += variable
        if variable not in usedVariables:
            usedVariables.append(variable)
        
    if ariety > 0:
        toReturn += ")"
    return toReturn

def getRandomAtom(needSafety):
    toReturn = ""
    predicateId = randint(0, numberOfPredicates-1)
    toReturn += "p_" + str(predicateId) 
    ariety = arieties[predicateId]
    if ariety > 0:
        toReturn += "("
    for i in range(arieties[predicateId]):
        if i > 0:
            toReturn += ","
        if (randint(0, constantRatio-1) == 0 and withConstants) or (needSafety and len(usedVariables)==0):
            toReturn += str(randint(0, maxConstant-1))
        else:
            if not needSafety:
                variable = "X_" + str(randint(0, numberOfVariables-1))
                toReturn += variable
                if variable not in usedVariables:
                    usedVariables.append(variable)
            else:
                toReturn += getUsedVariable()
    if ariety > 0:
        toReturn += ")"
    return toReturn




def getRandomArithmeticExpression():
    if len(usedVariables)==0:
        return "2 > 1"
    leftSide = getUsedVariable()
    relation =  getRandomElement(arithmeticRelations)
    if(randint(0, constantRatio-1) == 0):
        rightSide = str(randint(0, maxConstant-1))
    else:
        rightSide = getUsedVariable()


    if randint(0, 1) == 0:
        rightSide += " " + getRandomElement(arithmeticOperators) + " "
        rightSide += getUsedVariable()

    return leftSide + " " + relation + " " + rightSide
def getRandomAggregate(body):
    toReturn = "#count{"
    aggregateBody=""
    aggregateBodySize = random.randint(1,maxAggregateBodySize)
        
    for j in range(aggregateBodySize):
        if j > 0:
            aggregateBody+=','
        aggregateBody+=getRandomAggregateAtom()
    
    candidateAggregateVariable = []
        
    for v in usedVariables:
        if v in aggregateBody and v not in body:
            candidateAggregateVariable.append(v)
    if len(candidateAggregateVariable)==0:
        return ""
    numAggregateVariables = random.randint(1,len(candidateAggregateVariable))
    for j in range(numAggregateVariables):
        if j>0:
            toReturn+=','
        toReturn+=getRandomElement(candidateAggregateVariable)
    availableArithmeticRelation=[">",">=","<","<=","="]
    compareType = availableArithmeticRelation[random.randint(0,len(availableArithmeticRelation)-1)]
    toReturn+=":"+aggregateBody+"}"+compareType+str(randint(0, maxConstant-1))
    return toReturn

numberOfVariables = int(sys.argv[1])
numberOfRules = int(sys.argv[2])
numberOfPredicates = int(sys.argv[3])
maxArity = int(sys.argv[4])
maxBodySize = int(sys.argv[5])
maxAggregateBodySize = 3
maxHeadSize = int(sys.argv[6])
maxNFacts = int(sys.argv[7])
maxConstant = int(sys.argv[8])
constantRatio = int(sys.argv[9])
maxArithmeticExpressionsPerRule = int(sys.argv[10])

encoding = open("autogenerated/encoding", "w+")
instance = open("autogenerated/testInstances/instance", "w+")
constraint = open("autogenerated/constraint", "w+")


for i in range(numberOfPredicates):
    arieties.append(randint(1, maxArity))

for i in range(numberOfRules):
    bodySize = randint(1, maxBodySize)
    headSize = randint(0, maxHeadSize)
    body = ""
    head = ""
    numberOfNegatives = 0  # change to get negative literals in bodies
    #int numberOfNegatives = rand() % bodySize;
    #numberOfNegatives = randint(0, min(1,bodySize-1))
    numberOfExpressions = randint(0, maxArithmeticExpressionsPerRule)
    aggregate = 1 #change to randomly generate aggregate
    #aggregate = randint(0, 1)
    for j in range(bodySize):
        if j > 0:
            body += ", "
        if j >= bodySize - numberOfNegatives:
            body += "not " + getRandomAtom(True)
        else:
            body += getRandomAtom(False)

    if len(usedVariables) != 0:
        for j in range(numberOfExpressions):
            body += ","
            body += " " + getRandomArithmeticExpression() + " "

    for j in range(headSize):
        if j > 0:
            head += " | "
        head += getRandomAtom(True)


    if headSize == 0:
        if aggregate == 1:
            stringAggregate = getRandomAggregate(body)
            if stringAggregate!= "":
                body+=","+stringAggregate
        constraint.write(":-" + body + ".\n")
    else:
        encoding.write(head + ":-" + body + ".\n")
    usedVariables.clear()
nFacts = randint(0, maxNFacts)
for i in range(nFacts):
    predicate = randint(0, len(arieties)-1)
    ariety = arieties[predicate]
    instance.write("p_" + str(predicate))
    if ariety > 0:
        instance.write("(")
    for j in range(arieties[predicate]):
        if j > 0:
            instance.write(",")
        instance.write(str(randint(0,maxConstant)))
    if ariety > 0:
        instance.write(")")
    instance.write(".\n")
